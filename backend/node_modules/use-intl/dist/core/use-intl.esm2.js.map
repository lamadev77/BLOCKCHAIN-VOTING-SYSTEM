{"version":3,"file":"use-intl.esm2.js","sources":["../../src/core/createTranslator.tsx"],"sourcesContent":["import Formats from './Formats';\nimport IntlConfiguration from './IntlConfiguration';\nimport TranslationValues from './TranslationValues';\nimport createTranslatorImpl, {\n  CoreRichTranslationValues\n} from './createTranslatorImpl';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NamespaceKeys from './utils/NamespaceKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function createTranslator<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>({\n  onError = defaultOnError,\n  getMessageFallback = defaultGetMessageFallback,\n  messages,\n  namespace,\n  ...rest\n}: IntlConfiguration & {\n  messages: IntlMessages;\n  namespace?: NestedKey;\n}): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: CoreRichTranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return createTranslatorImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {\n      ...rest,\n      onError,\n      getMessageFallback,\n      messages: {'!': messages},\n      // @ts-ignore\n      namespace: namespace ? `!.${namespace}` : '!'\n    },\n    '!'\n  );\n}\n"],"names":["createTranslator","onError","defaultOnError","getMessageFallback","defaultGetMessageFallback","messages","namespace","rest","createTranslatorImpl"],"mappings":";;;;;AAYA;;;;;;;AAOG;;AACqB,SAAAA,gBAAA,CAcvB,IAAA,EAAA;AAAA,EAAA,IAAA,YAAA,GAAA,IAAA,CARCC,OAQD;AAAA,MARCA,OAQD,6BARWC,cAQX,GAAA,YAAA;AAAA,MAAA,qBAAA,GAAA,IAAA,CAPCC,kBAOD;AAAA,MAPCA,kBAOD,sCAPsBC,yBAOtB,GAAA,qBAAA;AAAA,MANCC,QAMD,QANCA,QAMD;AAAA,MALCC,SAKD,QALCA,SAKD;AAAA,MAJIC,IAIJ,GAAA,6BAAA,CAAA,IAAA,EAAA,SAAA,CAAA,CAAA;;AA4DC;AACA;AACA;AACA,EAAOC,OAAAA,oBAAoB,cAKpBD,IALoB,EAAA;AAMvBN,IAAAA,OAAO,EAAPA,OANuB;AAOvBE,IAAAA,kBAAkB,EAAlBA,kBAPuB;AAQvBE,IAAAA,QAAQ,EAAE;AAAC,MAAKA,GAAAA,EAAAA,QAAAA;AAAN,KARa;AASvB;AACAC,IAAAA,SAAS,EAAEA,SAAS,GAAA,IAAA,GAAQA,SAAR,GAAsB,GAAA;AAVnB,GAAA,CAAA,EAYzB,GAZyB,CAA3B,CAAA;AAcD;;;;"}