{"version":3,"file":"use-intl.cjs.production.min.js","sources":["../src/core/IntlError.tsx","../src/core/convertFormatsToIntlMessageFormat.tsx","../src/core/defaults.tsx","../src/core/createBaseTranslator.tsx","../src/core/resolveNamespace.tsx","../src/core/createFormatter.tsx","../src/core/createIntl.tsx","../src/react/IntlContext.tsx","../src/react/useIntlContext.tsx","../src/react/useNow.tsx","../src/react/useIntl.tsx","../src/react/IntlProvider.tsx","../src/core/createTranslator.tsx","../src/core/createTranslatorImpl.tsx","../src/react/useFormatter.tsx","../src/react/useLocale.tsx","../src/react/useTimeZone.tsx","../src/react/useTranslations.tsx","../src/react/useTranslationsImpl.tsx"],"sourcesContent":["export enum IntlErrorCode {\n  MISSING_MESSAGE = 'MISSING_MESSAGE',\n  MISSING_FORMAT = 'MISSING_FORMAT',\n  INSUFFICIENT_PATH = 'INSUFFICIENT_PATH',\n  INVALID_MESSAGE = 'INVALID_MESSAGE',\n  INVALID_KEY = 'INVALID_KEY',\n  FORMATTING_ERROR = 'FORMATTING_ERROR'\n}\n\nexport default class IntlError extends Error {\n  public readonly code: IntlErrorCode;\n  public readonly originalMessage: string | undefined;\n\n  constructor(code: IntlErrorCode, originalMessage?: string) {\n    let message: string = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\n","import {Formats as IntlFormats} from 'intl-messageformat';\nimport DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\n\nfunction setTimeZoneInFormats(\n  formats: Record<string, DateTimeFormatOptions> | undefined,\n  timeZone: string\n) {\n  if (!formats) return formats;\n\n  // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n  // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n  return Object.keys(formats).reduce(\n    (acc: Record<string, DateTimeFormatOptions>, key) => {\n      acc[key] = {\n        timeZone,\n        ...formats[key]\n      };\n      return acc;\n    },\n    {}\n  );\n}\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nexport default function convertFormatsToIntlMessageFormat(\n  formats: Partial<Formats>,\n  timeZone?: string\n): Partial<IntlFormats> {\n  const formatsWithTimeZone = timeZone\n    ? {...formats, dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)}\n    : formats;\n\n  return {\n    ...formatsWithTimeZone,\n    date: formatsWithTimeZone?.dateTime,\n    time: formatsWithTimeZone?.dateTime\n  };\n}\n","import IntlError from './IntlError';\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nexport function defaultGetMessageFallback(props: {\n  error: IntlError;\n  key: string;\n  namespace?: string;\n}) {\n  return [props.namespace, props.key].filter((part) => part != null).join('.');\n}\n\nexport function defaultOnError(error: IntlError) {\n  console.error(error);\n}\n","// eslint-disable-next-line import/no-named-as-default\nimport IntlMessageFormat from 'intl-messageformat';\nimport {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  ReactNodeArray\n} from 'react';\nimport AbstractIntlMessages from './AbstractIntlMessages';\nimport Formats from './Formats';\nimport {InitializedIntlConfiguration} from './IntlConfiguration';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport TranslationValues, {RichTranslationValues} from './TranslationValues';\nimport convertFormatsToIntlMessageFormat from './convertFormatsToIntlMessageFormat';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\nfunction resolvePath(\n  messages: AbstractIntlMessages | undefined,\n  key: string,\n  namespace?: string\n) {\n  if (!messages) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? `No messages available at \\`${namespace}\\`.`\n        : undefined\n    );\n  }\n\n  let message = messages;\n\n  key.split('.').forEach((part) => {\n    const next = (message as any)[part];\n\n    if (part == null || next == null) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `Could not resolve \\`${key}\\` in ${\n              namespace ? `\\`${namespace}\\`` : 'messages'\n            }.`\n          : undefined\n      );\n    }\n\n    message = next;\n  });\n\n  return message;\n}\n\nfunction prepareTranslationValues(values: RichTranslationValues) {\n  if (Object.keys(values).length === 0) return undefined;\n\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues: RichTranslationValues = {};\n  Object.keys(values).forEach((key) => {\n    let index = 0;\n    const value = values[key];\n\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = (chunks: ReactNode) => {\n        const result = value(chunks);\n\n        return isValidElement(result)\n          ? cloneElement(result, {key: key + index++})\n          : result;\n      };\n    } else {\n      transformed = value;\n    }\n\n    transformedValues[key] = transformed;\n  });\n\n  return transformedValues;\n}\n\nexport function getMessagesOrError<Messages extends AbstractIntlMessages>({\n  messages,\n  namespace,\n  onError = defaultOnError\n}: {\n  messages: Messages;\n  namespace?: string;\n  onError?(error: IntlError): void;\n}) {\n  try {\n    if (!messages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages were configured on the provider.`\n          : undefined\n      );\n    }\n\n    const retrievedMessages = namespace\n      ? resolvePath(messages, namespace)\n      : messages;\n\n    if (!retrievedMessages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages for namespace \\`${namespace}\\` found.`\n          : undefined\n      );\n    }\n\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(\n      IntlErrorCode.MISSING_MESSAGE,\n      (error as Error).message\n    );\n    onError(intlError);\n    return intlError;\n  }\n}\n\nexport type CreateBaseTranslatorProps<Messages> =\n  InitializedIntlConfiguration & {\n    cachedFormatsByLocale?: Record<string, Record<string, IntlMessageFormat>>;\n    defaultTranslationValues?: RichTranslationValues;\n    namespace?: string;\n    messagesOrError: Messages | IntlError;\n  };\n\nexport default function createBaseTranslator<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>({\n  cachedFormatsByLocale,\n  defaultTranslationValues,\n  formats: globalFormats,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}: CreateBaseTranslatorProps<Messages>) {\n  function getFallbackFromErrorAndNotify(\n    key: string,\n    code: IntlErrorCode,\n    message?: string\n  ) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({error, key, namespace});\n  }\n\n  function translateBaseFn(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: RichTranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    let message;\n    try {\n      message = resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n\n    const cacheKey = [namespace, key, message]\n      .filter((part) => part != null)\n      .join('.');\n\n    let messageFormat;\n    if (cachedFormatsByLocale?.[locale]?.[cacheKey]) {\n      messageFormat = cachedFormatsByLocale?.[locale][cacheKey];\n    } else {\n      if (typeof message === 'object') {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.INSUFFICIENT_PATH,\n          process.env.NODE_ENV !== 'production'\n            ? `Insufficient path specified for \\`${key}\\` in \\`${\n                namespace ? `\\`${namespace}\\`` : 'messages'\n              }\\`.`\n            : undefined\n        );\n      }\n\n      try {\n        messageFormat = new IntlMessageFormat(\n          message,\n          locale,\n          convertFormatsToIntlMessageFormat(\n            {...globalFormats, ...formats},\n            timeZone\n          )\n        );\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.INVALID_MESSAGE,\n          (error as Error).message\n        );\n      }\n\n      if (cachedFormatsByLocale) {\n        if (!cachedFormatsByLocale[locale]) {\n          cachedFormatsByLocale[locale] = {};\n        }\n        cachedFormatsByLocale[locale][cacheKey] = messageFormat;\n      }\n    }\n\n    try {\n      const formattedMessage = messageFormat.format(\n        // @ts-ignore `intl-messageformat` expects a different format\n        // for rich text elements since a recent minor update. This\n        // needs to be evaluated in detail, possibly also in regards\n        // to be able to format to parts.\n        prepareTranslationValues({...defaultTranslationValues, ...values})\n      );\n\n      if (formattedMessage == null) {\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `Unable to format \\`${key}\\` in ${\n                namespace ? `namespace \\`${namespace}\\`` : 'messages'\n              }`\n            : undefined\n        );\n      }\n\n      // Limit the function signature to return strings or React elements\n      return isValidElement(formattedMessage) ||\n        // Arrays of React elements\n        Array.isArray(formattedMessage) ||\n        typeof formattedMessage === 'string'\n        ? formattedMessage\n        : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.FORMATTING_ERROR,\n        (error as Error).message\n      );\n    }\n  }\n\n  function translateFn<\n    TargetKey extends MessageKeys<\n      NestedValueOf<Messages, NestedKey>,\n      NestedKeyOf<NestedValueOf<Messages, NestedKey>>\n    >\n  >(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: TargetKey,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: TranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string {\n    const result = translateBaseFn(key, values, formats);\n\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.INVALID_MESSAGE,\n        process.env.NODE_ENV !== 'production'\n          ? `The message \\`${key}\\` in ${\n              namespace ? `namespace \\`${namespace}\\`` : 'messages'\n            } didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`\n          : undefined\n      );\n    }\n\n    return result;\n  }\n\n  translateFn.rich = translateBaseFn;\n\n  translateFn.raw = (\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string\n  ): any => {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    try {\n      return resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n  };\n\n  return translateFn;\n}\n","/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nexport default function resolveNamespace(\n  namespace: string,\n  namespacePrefix: string\n) {\n  return namespace === namespacePrefix\n    ? undefined\n    : namespace.slice((namespacePrefix + '.').length);\n}\n","import DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport NumberFormatOptions from './NumberFormatOptions';\nimport {defaultOnError} from './defaults';\n\nconst MINUTE = 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst YEAR = DAY * 365;\n\nfunction getRelativeTimeFormatConfig(seconds: number) {\n  const absValue = Math.abs(seconds);\n  let value, unit: Intl.RelativeTimeFormatUnit;\n\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n\n  if (absValue < MINUTE) {\n    unit = 'second';\n    value = Math.round(seconds);\n  } else if (absValue < HOUR) {\n    unit = 'minute';\n    value = Math.round(seconds / MINUTE);\n  } else if (absValue < DAY) {\n    unit = 'hour';\n    value = Math.round(seconds / HOUR);\n  } else if (absValue < WEEK) {\n    unit = 'day';\n    value = Math.round(seconds / DAY);\n  } else if (absValue < MONTH) {\n    unit = 'week';\n    value = Math.round(seconds / WEEK);\n  } else if (absValue < YEAR) {\n    unit = 'month';\n    value = Math.round(seconds / MONTH);\n  } else {\n    unit = 'year';\n    value = Math.round(seconds / YEAR);\n  }\n\n  return {value, unit};\n}\n\ntype Props = {\n  locale: string;\n  timeZone?: string;\n  onError?(error: IntlError): void;\n  formats?: Partial<Formats>;\n  now?: Date;\n};\n\nexport default function createFormatter({\n  formats,\n  locale,\n  now: globalNow,\n  onError = defaultOnError,\n  timeZone\n}: Props) {\n  function resolveFormatOrOptions<Options>(\n    typeFormats: Record<string, Options> | undefined,\n    formatOrOptions?: string | Options\n  ) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n\n      if (!options) {\n        const error = new IntlError(\n          IntlErrorCode.MISSING_FORMAT,\n          process.env.NODE_ENV !== 'production'\n            ? `Format \\`${formatName}\\` is not available. You can configure it on the provider or provide custom options.`\n            : undefined\n        );\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n\n    return options;\n  }\n\n  function getFormattedValue<Value, Options>(\n    value: Value,\n    formatOrOptions: string | Options | undefined,\n    typeFormats: Record<string, Options> | undefined,\n    formatter: (options?: Options) => string\n  ) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n    } catch (error) {\n      return String(value);\n    }\n\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(value);\n    }\n  }\n\n  function dateTime(\n    /** If a number is supplied, this is interpreted as a UTC timestamp. */\n    value: Date | number,\n    /** If a time zone is supplied, the `value` is converted to that time zone.\n     * Otherwise the user time zone will be used. */\n    formatOrOptions?: string | DateTimeFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.dateTime,\n      (options) => {\n        if (timeZone && !options?.timeZone) {\n          options = {...options, timeZone};\n        }\n\n        return new Intl.DateTimeFormat(locale, options).format(value);\n      }\n    );\n  }\n\n  function number(\n    value: number | bigint,\n    formatOrOptions?: string | NumberFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.number,\n      (options) => new Intl.NumberFormat(locale, options).format(value)\n    );\n  }\n\n  function relativeTime(\n    /** The date time that needs to be formatted. */\n    date: number | Date,\n    /** The reference point in time to which `date` will be formatted in relation to.  */\n    now?: number | Date\n  ) {\n    try {\n      if (!now) {\n        if (globalNow) {\n          now = globalNow;\n        } else {\n          throw new Error(\n            process.env.NODE_ENV !== 'production'\n              ? `The \\`now\\` parameter wasn't provided and there was no global fallback configured on the provider.`\n              : undefined\n          );\n        }\n      }\n\n      const dateDate = date instanceof Date ? date : new Date(date);\n      const nowDate = now instanceof Date ? now : new Date(now);\n\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      const {unit, value} = getRelativeTimeFormatConfig(seconds);\n\n      return new Intl.RelativeTimeFormat(locale, {\n        numeric: 'auto'\n      }).format(value, unit);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(date);\n    }\n  }\n\n  return {dateTime, number, relativeTime};\n}\n","import createFormatter from './createFormatter';\n\n/** @deprecated Switch to `createFormatter` */\nexport default function createIntl(\n  ...args: Parameters<typeof createFormatter>\n) {\n  const formatter = createFormatter(...args);\n  return {\n    formatDateTime: formatter.dateTime,\n    formatNumber: formatter.number,\n    formatRelativeTime: formatter.relativeTime\n  };\n}\n","import {createContext} from 'react';\nimport AbstractIntlMessages from '../core/AbstractIntlMessages';\nimport Formats from '../core/Formats';\nimport IntlError from '../core/IntlError';\nimport {RichTranslationValues} from '../core/TranslationValues';\n\nexport type IntlContextShape = {\n  messages?: AbstractIntlMessages;\n  locale: string;\n  formats?: Partial<Formats>;\n  timeZone?: string;\n  onError(error: IntlError): void;\n  getMessageFallback(info: {\n    error: IntlError;\n    key: string;\n    namespace?: string;\n  }): string;\n  now?: Date;\n  defaultTranslationValues?: RichTranslationValues;\n};\n\nconst IntlContext = createContext<IntlContextShape | undefined>(undefined);\n\nexport default IntlContext;\n","import {useContext} from 'react';\nimport IntlContext from './IntlContext';\n\nexport default function useIntlContext() {\n  const context = useContext(IntlContext);\n\n  if (!context) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? 'No intl context found. Have you configured the provider?'\n        : undefined\n    );\n  }\n\n  return context;\n}\n","import {useState, useEffect} from 'react';\nimport useIntlContext from './useIntlContext';\n\ntype Options = {\n  updateInterval?: number;\n};\n\nfunction getNow() {\n  return new Date();\n}\n\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */\nexport default function useNow(options?: Options) {\n  const updateInterval = options?.updateInterval;\n\n  const {now: globalNow} = useIntlContext();\n  const [now, setNow] = useState(globalNow || getNow());\n\n  useEffect(() => {\n    if (!updateInterval) return;\n\n    const intervalId = setInterval(() => {\n      setNow(getNow());\n    }, updateInterval);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n\n  return now;\n}\n","import {useMemo} from 'react';\nimport createIntl from '../core/createIntl';\nimport useIntlContext from './useIntlContext';\n\nlet hasWarned = false;\n\n/** @deprecated  Switch to `useFormatter` */\nexport default function useIntl() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  if (!hasWarned) {\n    hasWarned = true;\n    console.warn(\n      '`useIntl()` is deprecated and will be removed in the next major version. Please switch to `useFormatter()`.'\n    );\n  }\n\n  return useMemo(\n    () =>\n      createIntl({\n        formats,\n        locale,\n        now: globalNow,\n        onError,\n        timeZone\n      }),\n    [formats, globalNow, locale, onError, timeZone]\n  );\n}\n","import React, {ReactNode, useEffect} from 'react';\nimport {AbstractIntlMessages} from '../core';\nimport IntlConfiguration from '../core/IntlConfiguration';\nimport {RichTranslationValues} from '../core/TranslationValues';\nimport {defaultGetMessageFallback, defaultOnError} from '../core/defaults';\nimport validateMessages from '../core/validateMessages';\nimport IntlContext from './IntlContext';\n\ntype Props = IntlConfiguration & {\n  /** All components that use the provided hooks should be within this tree. */\n  children: ReactNode;\n  /** Global default values for translation values and rich text elements.\n   * Can be used for consistent usage or styling of rich text elements.\n   * Defaults will be overidden by locally provided values. */\n  defaultTranslationValues?: RichTranslationValues;\n  /** All messages that will be available in your components. */\n  messages?: AbstractIntlMessages;\n};\n\nexport default function IntlProvider({\n  children,\n  onError = defaultOnError,\n  getMessageFallback = defaultGetMessageFallback,\n  messages,\n  ...contextValues\n}: Props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (messages) {\n        validateMessages(messages, onError);\n      }\n    }, [messages, onError]);\n  }\n\n  return (\n    <IntlContext.Provider\n      value={{...contextValues, messages, onError, getMessageFallback}}\n    >\n      {children}\n    </IntlContext.Provider>\n  );\n}\n","import Formats from './Formats';\nimport IntlConfiguration from './IntlConfiguration';\nimport TranslationValues from './TranslationValues';\nimport createTranslatorImpl, {\n  CoreRichTranslationValues\n} from './createTranslatorImpl';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NamespaceKeys from './utils/NamespaceKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function createTranslator<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>({\n  onError = defaultOnError,\n  getMessageFallback = defaultGetMessageFallback,\n  messages,\n  namespace,\n  ...rest\n}: IntlConfiguration & {\n  messages: IntlMessages;\n  namespace?: NestedKey;\n}): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: CoreRichTranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return createTranslatorImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {\n      ...rest,\n      onError,\n      getMessageFallback,\n      messages: {'!': messages},\n      // @ts-ignore\n      namespace: namespace ? `!.${namespace}` : '!'\n    },\n    '!'\n  );\n}\n","import AbstractIntlMessages from './AbstractIntlMessages';\nimport {InitializedIntlConfiguration} from './IntlConfiguration';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport {RichTranslationValues, TranslationValue} from './TranslationValues';\nimport createBaseTranslator, {getMessagesOrError} from './createBaseTranslator';\nimport resolveNamespace from './resolveNamespace';\nimport NestedKeyOf from './utils/NestedKeyOf';\n\nexport type CoreRichTranslationValues = Record<\n  string,\n  TranslationValue | ((chunks: string) => string)\n>;\n\nexport type CreateTranslatorImplProps<Messages> =\n  InitializedIntlConfiguration & {\n    namespace: string;\n    messages: Messages;\n  };\n\nexport default function createTranslatorImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(\n  {\n    getMessageFallback,\n    messages,\n    namespace,\n    onError,\n    ...rest\n  }: CreateTranslatorImplProps<Messages>,\n  namespacePrefix: string\n) {\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const translator = createBaseTranslator<Messages, NestedKey>({\n    ...rest,\n    onError,\n    getMessageFallback,\n    messagesOrError: getMessagesOrError({\n      messages,\n      namespace,\n      onError\n    }) as Messages | IntlError\n  });\n\n  const originalRich = translator.rich;\n\n  function base(...args: Parameters<typeof translator>) {\n    return translator(...args);\n  }\n\n  // Augment `t.rich` to return plain strings\n  base.rich = (\n    key: Parameters<typeof originalRich>[0],\n    /** Key value pairs for values to interpolate into the message. */\n    values: CoreRichTranslationValues,\n    formats?: Parameters<typeof originalRich>[2]\n  ): string => {\n    // `chunks` is returned as a string when no React element\n    // is used, therefore it's safe to cast this type.\n    const result = originalRich(key, values as RichTranslationValues, formats);\n\n    // When only string chunks are provided to the parser, only strings should be returned here.\n    if (typeof result !== 'string') {\n      const error = new IntlError(\n        IntlErrorCode.FORMATTING_ERROR,\n        process.env.NODE_ENV !== 'production'\n          ? \"`createTranslator` only accepts functions for rich text formatting that receive and return strings.\\n\\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})\"\n          : undefined\n      );\n\n      onError(error);\n      return getMessageFallback({error, key, namespace});\n    }\n\n    return result;\n  };\n\n  base.raw = translator.raw;\n\n  return base;\n}\n","import {useMemo} from 'react';\nimport createFormatter from '../core/createFormatter';\nimport useIntlContext from './useIntlContext';\n\nexport default function useFormatter() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  return useMemo(\n    () =>\n      createFormatter({\n        formats,\n        locale,\n        now: globalNow,\n        onError,\n        timeZone\n      }),\n    [formats, globalNow, locale, onError, timeZone]\n  );\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useLocale() {\n  return useIntlContext().locale;\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useTimeZone() {\n  return useIntlContext().timeZone;\n}\n","import {ReactElement, ReactNodeArray} from 'react';\nimport Formats from '../core/Formats';\nimport TranslationValues, {\n  RichTranslationValues\n} from '../core/TranslationValues';\nimport MessageKeys from '../core/utils/MessageKeys';\nimport NamespaceKeys from '../core/utils/NamespaceKeys';\nimport NestedKeyOf from '../core/utils/NestedKeyOf';\nimport NestedValueOf from '../core/utils/NestedValueOf';\nimport useIntlContext from './useIntlContext';\nimport useTranslationsImpl from './useTranslationsImpl';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function useTranslations<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>(\n  namespace?: NestedKey\n): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: RichTranslationValues,\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  const context = useIntlContext();\n  const messages = context.messages as IntlMessages;\n\n  // We have to wrap the actual hook so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return useTranslationsImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {'!': messages},\n    // @ts-ignore\n    namespace ? `!.${namespace}` : '!',\n    '!'\n  );\n}\n","import {IntlMessageFormat} from 'intl-messageformat';\nimport {useMemo, useRef} from 'react';\nimport AbstractIntlMessages from '../core/AbstractIntlMessages';\nimport createBaseTranslator, {\n  getMessagesOrError\n} from '../core/createBaseTranslator';\nimport resolveNamespace from '../core/resolveNamespace';\nimport NestedKeyOf from '../core/utils/NestedKeyOf';\nimport useIntlContext from './useIntlContext';\n\nexport default function useTranslationsImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(allMessages: Messages, namespace: NestedKey, namespacePrefix: string) {\n  const {\n    defaultTranslationValues,\n    formats: globalFormats,\n    getMessageFallback,\n    locale,\n    onError,\n    timeZone\n  } = useIntlContext();\n\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the hook invocation.\n  allMessages = allMessages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const cachedFormatsByLocaleRef = useRef<\n    Record<string, Record<string, IntlMessageFormat>>\n  >({});\n\n  const messagesOrError = useMemo(\n    () => getMessagesOrError({messages: allMessages, namespace, onError}),\n    [allMessages, namespace, onError]\n  );\n\n  const translate = useMemo(\n    () =>\n      createBaseTranslator({\n        cachedFormatsByLocale: cachedFormatsByLocaleRef.current,\n        getMessageFallback,\n        messagesOrError,\n        defaultTranslationValues,\n        namespace,\n        onError,\n        formats: globalFormats,\n        locale,\n        timeZone\n      }),\n    [\n      getMessageFallback,\n      messagesOrError,\n      defaultTranslationValues,\n      namespace,\n      onError,\n      globalFormats,\n      locale,\n      timeZone\n    ]\n  );\n\n  return translate;\n}\n"],"names":["IntlErrorCode","IntlError","code","originalMessage","_this","message","_Error","call","this","Error","setTimeZoneInFormats","formats","timeZone","Object","keys","reduce","acc","key","_extends","defaultGetMessageFallback","props","namespace","filter","part","join","defaultOnError","error","console","resolvePath","messages","undefined","split","forEach","next","getMessagesOrError","_ref","_ref$onError","onError","retrievedMessages","intlError","MISSING_MESSAGE","createBaseTranslator","_ref2","cachedFormatsByLocale","defaultTranslationValues","globalFormats","_ref2$getMessageFallb","getMessageFallback","locale","messagesOrError","getFallbackFromErrorAndNotify","translateBaseFn","values","_cachedFormatsByLocal","messageFormat","cacheKey","INSUFFICIENT_PATH","IntlMessageFormat","formatsWithTimeZone","dateTime","date","time","convertFormatsToIntlMessageFormat","INVALID_MESSAGE","formattedMessage","format","length","transformedValues","index","value","chunks","result","isValidElement","cloneElement","prepareTranslationValues","Array","isArray","String","FORMATTING_ERROR","translateFn","rich","raw","resolveNamespace","namespacePrefix","slice","createFormatter","globalNow","now","getFormattedValue","formatOrOptions","typeFormats","formatter","options","MISSING_FORMAT","resolveFormatOrOptions","_options","Intl","DateTimeFormat","number","NumberFormat","relativeTime","dateDate","Date","nowDate","getRelativeTimeFormatConfig","seconds","unit","absValue","Math","abs","round","MINUTE","HOUR","DAY","getTime","RelativeTimeFormat","numeric","createIntl","apply","arguments","formatDateTime","formatNumber","formatRelativeTime","IntlContext","createContext","useIntlContext","context","useContext","getNow","hasWarned","children","_ref$getMessageFallba","contextValues","_objectWithoutPropertiesLoose","_excluded","React","Provider","createTranslatorImpl","rest","translator","originalRich","base","_useIntlContext","useMemo","warn","updateInterval","_useState","useState","setNow","useEffect","intervalId","setInterval","clearInterval","allMessages","cachedFormatsByLocaleRef","useRef","current","useTranslationsImpl"],"mappings":"uMAAYA,q+CAAAA,QAAZA,mBAAA,GAAYA,EAAAA,wBAAAA,QAAAA,cAOX,KANC,gBAAA,kBACAA,EAAA,eAAA,iBACAA,EAAA,kBAAA,oBACAA,EAAA,gBAAA,kBACAA,EAAA,YAAA,cACAA,EAAA,iBAAA,uBAGmBC,sBAIPC,SAAAA,EAAAA,EAAqBC,GAAwB,IAAAC,EACnDC,EAAkBH,EADiC,OAEnDC,IACFE,GAAW,KAAOF,IAEpBC,EAAAE,EAAAC,KAAAC,KAAMH,IAANG,MARcN,UAGyC,EAAAE,EAFzCD,qBAEyC,EAOlDD,EAAAA,KAAOA,EACRC,IACGA,EAAAA,gBAAkBA,GAT8BC,8FAJpBK,QCLvC,SAASC,EACPC,EACAC,GAEA,OAAKD,EAIEE,OAAOC,KAAKH,GAASI,QAC1B,SAACC,EAA4CC,GAK3C,OAJAD,EAAIC,GAAJC,EAAA,CACEN,SAAAA,GACGD,EAAQM,IAEND,IAET,IAZmBL,ECDjB,SAAUQ,EAA0BC,GAKxC,MAAO,CAACA,EAAMC,UAAWD,EAAMH,KAAKK,QAAO,SAACC,GAASA,OAAQ,MAARA,KAAcC,KAAK,KAGpE,SAAUC,EAAeC,GAC7BC,QAAQD,MAAMA,GCIhB,SAASE,EACPC,EACAZ,EACAI,GAEI,IAACQ,EACH,MAAM,IAAIpB,WAGJqB,GAIJzB,IAAAA,EAAUwB,EAkBd,OAhBAZ,EAAIc,MAAM,KAAKC,SAAQ,SAACT,GACtB,IAAMU,EAAQ5B,EAAgBkB,GAE9B,GAAY,MAARA,GAAwB,MAARU,EACZ,MAAA,IAAIxB,WAKJqB,GAIRzB,EAAU4B,KAGL5B,EA+BH,SAAU6B,EAQfC,GAPCN,IAAAA,IAAAA,SACAR,IAAAA,UAMDe,EAAAD,EALCE,QAAAA,aAAUZ,EAKXW,EACK,IACE,IAACP,EACH,MAAM,IAAIpB,WAGJqB,GAIFQ,IAAAA,EAAoBjB,EACtBO,EAAYC,EAAUR,GACtBQ,EAEA,IAACS,EACH,MAAM,IAAI7B,WAGJqB,GAIR,OAAOQ,EACP,MAAOZ,GACP,IAAMa,EAAY,IAAItC,EACpBD,QAAAA,cAAcwC,gBACbd,EAAgBrB,SAGnB,OADAgC,EAAQE,GACDA,GAYG,SAAUE,EAacC,GATpCC,IAAAA,IAAAA,sBACAC,IAAAA,yBACSC,IAATlC,QAOoCmC,EAAAJ,EANpCK,mBAAAA,aAAqB5B,EAMe2B,EALpCE,IAAAA,OACAC,IAAAA,gBACA5B,IAAAA,UACAgB,IAAAA,QACAzB,IAAAA,SAEA,SAASsC,EACPjC,EACAf,EACAG,GAEMqB,IAAAA,EAAQ,IAAIzB,EAAUC,EAAMG,GAElC,OADAgC,EAAQX,GACDqB,EAAmB,CAACrB,MAAAA,EAAOT,IAAAA,EAAKI,UAAAA,IAGzC,SAAS8B,EAEPlC,EAEAmC,EAEAzC,GAA0B,IAAA0C,EAEtBJ,GAAAA,aAA2BhD,EAE7B,OAAO8C,EAAmB,CACxBrB,MAAOuB,EACPhC,IAAAA,EACAI,UAAAA,IAGEQ,IAEFxB,EAFEwB,EAAWoB,EAGb,IACF5C,EAAUuB,EAAYC,EAAUZ,GAChC,MAAOS,GACAwB,OAAAA,EACLjC,EACAjB,QAAAA,cAAcwC,gBACbd,EAAgBrB,SAIrB,IAIIiD,EAJEC,EAAW,CAAClC,EAAWJ,EAAKZ,GAC/BiB,QAAO,SAACC,GAASA,OAAQ,MAARA,KACjBC,KAAK,KAGJmB,GAAAA,MAAAA,GAAA,OAAAA,EAAAA,EAAwBK,KAAxBK,EAAkCE,GACpCD,EAAgBX,MAAAA,OAAAA,EAAAA,EAAwBK,GAAQO,OAC3C,CACL,GAAuB,iBAAZlD,EACF6C,OAAAA,EACLjC,EACAjB,QAAaA,cAACwD,uBAKV1B,GAIJ,IACFwB,EAAgB,IAAIG,EAAAA,QAClBpD,EACA2C,EFhLI,SACZrC,EACAC,GAEA,IAAM8C,EAAsB9C,EAAQM,EAAA,GAC5BP,EAD4B,CACnBgD,SAAUjD,EAAqBC,EAAQgD,SAAU/C,KAC9DD,EAEJ,OAAAO,EAAA,GACKwC,EADL,CAEEE,KAAMF,MAAAA,OAAAA,EAAAA,EAAqBC,SAC3BE,KAAI,MAAEH,OAAF,EAAEA,EAAqBC,WEsKrBG,MACMjB,EAAkBlC,GACtBC,IAGJ,MAAOc,GACAwB,OAAAA,EACLjC,EACAjB,QAAAA,cAAc+D,gBACbrC,EAAgBrB,SAIjBsC,IACGA,EAAsBK,KACzBL,EAAsBK,GAAU,IAElCL,EAAsBK,GAAQO,GAAYD,GAI1C,IACF,IAAMU,EAAmBV,EAAcW,OAhL7C,SAAkCb,GAChC,GAAmC,IAA/BvC,OAAOC,KAAKsC,GAAQc,OAAxB,CAGMC,IAAAA,EAA2C,GAqBjD,OApBAtD,OAAOC,KAAKsC,GAAQpB,SAAQ,SAACf,GACvBmD,IAAAA,EAAQ,EACNC,EAAQjB,EAAOnC,GAerBkD,EAAkBlD,GAZG,mBAAVoD,EACK,SAACC,GACb,IAAMC,EAASF,EAAMC,GAEdE,OAAAA,iBAAeD,GAClBE,EAAAA,aAAaF,EAAQ,CAACtD,IAAKA,EAAMmD,MACjCG,GAGQF,KAMXF,GA4JDO,CAA6B9B,EAAAA,GAAAA,EAA6BQ,KAGxDY,GAAoB,MAApBA,EACI,MAAA,IAAIvD,WAKJqB,GAKR,OAAO0C,EAAAA,eAAeR,IAEpBW,MAAMC,QAAQZ,IACc,iBAArBA,EACLA,EACAa,OAAOb,GACX,MAAOtC,GACAwB,OAAAA,EACLjC,EACAjB,QAAAA,cAAc8E,iBACbpD,EAAgBrB,UAKvB,SAAS0E,EAOP9D,EAEAmC,EAEAzC,GAEM4D,IAAAA,EAASpB,EAAgBlC,EAAKmC,EAAQzC,GAE5C,MAAsB,iBAAX4D,EACFrB,EACLjC,EACAjB,QAAaA,cAAC+D,qBAKVjC,GAIDyC,EA8BT,OA3BAQ,EAAYC,KAAO7B,EAEnB4B,EAAYE,IAAM,SAEhBhE,GAEIgC,GAAAA,aAA2BhD,EAE7B,OAAO8C,EAAmB,CACxBrB,MAAOuB,EACPhC,IAAAA,EACAI,UAAAA,IAGEQ,IAAAA,EAAWoB,EAEb,IACF,OAAOrB,EAAYC,EAAUZ,GAC7B,MAAOS,GACAwB,OAAAA,EACLjC,EACAjB,QAAAA,cAAcwC,gBACbd,EAAgBrB,WAKhB0E,EC7TK,SAAUG,EACtB7D,EACA8D,GAEA,OAAO9D,IAAc8D,OACjBrD,EACAT,EAAU+D,OAAOD,EAAkB,KAAKjB,gIC4ChC,SAAUmB,EAMhBlD,GALNxB,IAAAA,IAAAA,QACAqC,IAAAA,OACKsC,IAALC,IAGMnD,EAAAD,EAFNE,QAAAA,aAAUZ,EAEJW,EADNxB,IAAAA,SA4BS4E,SAAAA,EACPnB,EACAoB,EACAC,EACAC,GAEA,IAAIC,EACA,IACFA,EAlCJ,SACEF,EACAD,GAEA,IAAIG,EACJ,GAA+B,iBAApBH,GAIL,KAFJG,QAAUF,SAAAA,EADSD,IAGL,CACN/D,IAAAA,EAAQ,IAAIzB,EAChBD,QAAaA,cAAC6F,oBAGV/D,GAGN,MADAO,EAAQX,GACFA,QAGRkE,EAAUH,EAGZ,OAAOG,EAWKE,CAAuBJ,EAAaD,GAC9C,MAAO/D,GACAmD,OAAAA,OAAOR,GAGZ,IACKsB,OAAAA,EAAUC,GACjB,MAAOlE,GAIAmD,OAHPxC,EACE,IAAIpC,EAAUD,QAAaA,cAAC8E,iBAAmBpD,EAAgBrB,UAE1DwE,OAAOR,IAyEX,MAAA,CAACV,SArER,SAEEU,EAGAoB,GAEA,OAAOD,EACLnB,EACAoB,EACA9E,MAAAA,OAAAA,EAAAA,EAASgD,UACT,SAACiC,GAAW,IAAAG,EAKV,OAJInF,UAAagF,EAAAA,IAAAG,EAASnF,WACxBgF,OAAcA,EAAP,CAAgBhF,SAAAA,KAGlB,IAAIoF,KAAKC,eAAejD,EAAQ4C,GAAS3B,OAAOI,OAqD3C6B,OAhDlB,SACE7B,EACAoB,GAEA,OAAOD,EACLnB,EACAoB,EAFsB,MAGtB9E,OAHsB,EAGtBA,EAASuF,QACT,SAACN,GAAD,OAAa,IAAII,KAAKG,aAAanD,EAAQ4C,GAAS3B,OAAOI,OAwCrC+B,aApC1B,SAEExC,EAEA2B,GAEI,IACE,IAACA,EAAK,CACR,IAAID,EAGF,MAAM,IAAI7E,WAGJqB,GALNyD,EAAMD,EAUV,IAAMe,EAAWzC,aAAgB0C,KAAO1C,EAAO,IAAI0C,KAAK1C,GAClD2C,EAAUhB,aAAee,KAAOf,EAAM,IAAIe,KAAKf,GAG/BiB,EAzJ5B,SAAqCC,GACnC,IACIpC,EAAOqC,EADLC,EAAWC,KAAKC,IAAIJ,GA6BnB,OAvBHE,EAdS,IAeXD,EAAO,SACPrC,EAAQuC,KAAKE,MAAML,IACVE,EAhBAI,MAiBTL,EAAO,SACPrC,EAAQuC,KAAKE,MAAML,EAnBR,KAoBFE,EAlBDK,OAmBRN,EAAO,OACPrC,EAAQuC,KAAKE,MAAML,EArBVM,OAsBAJ,EApBAM,QAqBTP,EAAO,MACPrC,EAAQuC,KAAKE,MAAML,EAvBXO,QAwBCL,EAtBCM,QAuBVP,EAAO,OACPrC,EAAQuC,KAAKE,MAAML,EAzBVQ,SA0BAN,EAxBAM,SAyBTP,EAAO,QACPrC,EAAQuC,KAAKE,MAAML,EA3BTQ,UA6BVP,EAAO,OACPrC,EAAQuC,KAAKE,MAAML,EA7BVQ,UAgCJ,CAAC5C,MAAAA,EAAOqC,KAAAA,GA2HWF,EADLH,EAASa,UAAYX,EAAQW,WAAa,KACpDR,IAAAA,KAAMrC,IAAAA,MAEb,OAAO,IAAI2B,KAAKmB,mBAAmBnE,EAAQ,CACzCoE,QAAS,SACRnD,OAAOI,EAAOqC,GACjB,MAAOhF,GAIAmD,OAHPxC,EACE,IAAIpC,EAAUD,QAAaA,cAAC8E,iBAAmBpD,EAAgBrB,UAE1DwE,OAAOjB,MC5KN,SAAUyD,IAGtB,IAAM1B,EAAYN,EAAeiC,WAAjC,EAAAC,WACO,MAAA,CACLC,eAAgB7B,EAAUhC,SAC1B8D,aAAc9B,EAAUO,OACxBwB,mBAAoB/B,EAAUS,cCWlC,IAAMuB,EAAcC,EAAaA,mBAA+B9F,4DClBlD,SAAU+F,IACtB,IAAMC,EAAUC,aAAWJ,GAEvB,IAACG,EACH,MAAM,IAAIrH,WAGJqB,GAIR,OAAOgG,ECPT,SAASE,IACA,OAAA,IAAI1B,KCJb,IAAI2B,GAAY,2CCeQ,SAMhB9F,GALN+F,IAAAA,IAAAA,SAKM9F,EAAAD,EAJNE,QAAAA,aAAUZ,EAIJW,EAAA+F,EAAAhG,EAHNY,mBAAAA,aAAqB5B,EAGfgH,EAFNtG,IAAAA,SACGuG,EACGC,EAAAlG,EAAAmG,GAUN,OACEC,wBAACZ,EAAYa,SACX,CAAAnE,WAAW+D,EAAN,CAAqBvG,SAAAA,EAAUQ,QAAAA,EAASU,mBAAAA,KAE5CmF,4ECnBiB,SAcvB/F,GAAA,IAAAC,EAAAD,EARCE,QAAAA,aAAUZ,EAQXW,EAAA+F,EAAAhG,EAPCY,mBAAAA,aAAqB5B,EAOtBgH,EANCtG,IAAAA,SACAR,IAAAA,UAoEOoH,OC9EK,SAWZtD,EAAAA,GANEpC,IAAAA,IAAAA,mBACAlB,IAAAA,SACAR,IAAAA,UACAgB,IAAAA,QACGqG,EAEkBL,EAAAlG,EAAAmG,GAIvBzG,EAAWA,ED2ET,KC1EFR,EAAY6D,EAAiB7D,ED0E3B,KCxEF,IAAMsH,EAAalG,EAAoBvB,EAAA,GAClCwH,EADkC,CAErCrG,QAAAA,EACAU,mBAAAA,EACAE,gBAAiBf,EAAmB,CAClCL,SAAAA,EACAR,UAAAA,EACAgB,QAAAA,OAIEuG,EAAeD,EAAW3D,KAEhC,SAAS6D,IACAF,OAAAA,aAAP,EAAApB,WAgCF,OA5BAsB,EAAK7D,KAAO,SACV/D,EAEAmC,EACAzC,GAIM4D,IAAAA,EAASqE,EAAa3H,EAAKmC,EAAiCzC,GAGlE,GAAsB,iBAAX4D,EAAqB,CACxB7C,IAAAA,EAAQ,IAAIzB,EAChBD,QAAaA,cAAC8E,sBAGVhD,GAIN,OADAO,EAAQX,GACDqB,EAAmB,CAACrB,MAAAA,EAAOT,IAAAA,EAAKI,UAAAA,IAGzC,OAAOkD,GAGTsE,EAAK5D,IAAM0D,EAAW1D,IAEf4D,EDcAJ,MA/DRJ,EAAAlG,EAAAmG,GA+D4B,CAMvBjG,QAAAA,EACAU,mBAAAA,EACAlB,SAAU,CAAMA,IAAAA,GAEhBR,UAAWA,EAAS,KAAQA,EAAc,6BEvGlC,WACZ,IAAAyH,EAA6DjB,IAAtDlH,IAAAA,QAASqC,IAAAA,OAAasC,IAALC,IAAgBlD,IAAAA,QAASzB,IAAAA,SAEjD,OAAOmI,EAAOA,SACZ,WAAA,OACE1D,EAAgB,CACd1E,QAAAA,EACAqC,OAAAA,EACAuC,IAAKD,EACLjD,QAAAA,EACAzB,SAAAA,MAEJ,CAACD,EAAS2E,EAAWtC,EAAQX,EAASzB,qBJT5B,WACZ,IAAAkI,EAA6DjB,IAAtDlH,IAAAA,QAASqC,IAAAA,OAAasC,IAALC,IAAgBlD,IAAAA,QAASzB,IAAAA,SASjD,OAPKqH,IACHA,GAAY,EACZtG,QAAQqH,KACN,gHAIGD,EAAOA,SACZ,WAAA,OACE1B,EAAW,CACT1G,QAAAA,EACAqC,OAAAA,EACAuC,IAAKD,EACLjD,QAAAA,EACAzB,SAAAA,MAEJ,CAACD,EAAS2E,EAAWtC,EAAQX,EAASzB,uBKxB5B,WACLiH,OAAAA,IAAiB7E,uBN0BF,SAAO4C,GAC7B,IAAMqD,EAAiBrD,MAAAA,OAAAA,EAAAA,EAASqD,eAEpB3D,EAAauC,IAAlBtC,IACP2D,EAAsBC,EAAAA,SAAS7D,GAAa0C,KAArCzC,EAAP2D,EAAA,GAAYE,EAAZF,EAAA,GAcA,OAZAG,EAAAA,WAAU,WACJ,GAACJ,EAAD,CAEJ,IAAMK,EAAaC,aAAY,WAC7BH,EAAOpB,OACNiB,GAEH,OAAO,WACLO,cAAcF,OAEf,CAAChE,EAAW2D,IAER1D,uBO7CK,WACLsC,OAAAA,IAAiBjH,kCCiBF,SAMtBS,GAmEA,OCnFsB,SAGtBoI,EAAuBpI,EAAsB8D,GAC7C,IAAA2D,EAOIjB,IANFjF,IAAAA,yBACSC,IAATlC,QACAoC,IAAAA,mBACAC,IAAAA,OACAX,IAAAA,QACAzB,EANFkI,EAMElI,SAKF6I,EAAcA,ED2EZ,KC1EFpI,EAAY6D,EAAiB7D,ED0E3B,KCxEF,IAAMqI,EAA2BC,SAE/B,IAEI1G,EAAkB8F,EAAAA,SACtB,WAAA,OAAM7G,EAAmB,CAACL,SAAU4H,EAAapI,UAAAA,EAAWgB,QAAAA,MAC5D,CAACoH,EAAapI,EAAWgB,IA4B3B,OAzBkB0G,EAAAA,SAChB,WAAA,OACEtG,EAAqB,CACnBE,sBAAuB+G,EAAyBE,QAChD7G,mBAAAA,EACAE,gBAAAA,EACAL,yBAAAA,EACAvB,UAAAA,EACAgB,QAAAA,EACA1B,QAASkC,EACTG,OAAAA,EACApC,SAAAA,MAEJ,CACEmC,EACAE,EACAL,EACAvB,EACAgB,EACAQ,EACAG,EACApC,IDmCGiJ,CAIL,CAAMhI,IAVQgG,IACShG,UAWvBR,EAAiBA,KAAAA,EAAc"}